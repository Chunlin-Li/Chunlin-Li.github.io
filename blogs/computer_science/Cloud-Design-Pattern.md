Cloud Design Patterns
==========================

[原文](https://msdn.microsoft.com/en-us/library/dn568099.aspx)


[TOC]

## Cache-Aside 模式

**Read:**

> 1. 检查数据当前是否在缓存中
> 2. 如果数据不在缓存中, 则从数据库读取
> 3. 将数据的拷贝保存在缓存中

**Write: **

> 1. 如果数据不在缓存中,  直接写到数据库
> 2. 如果数据在缓存中, 则删除缓存中的数据拷贝.

#### 注意: 

* 缓存生命周期: 通常缓存数据会设置过期时间, 过长过短都会有问题. 缓存时间需要根据应用的数据访问模型来进行设置. 另外要注意, 缓存只在相对静态的数据或读显著高于写的情景下才能提高效率.
* 数据的淘汰(Evicting): 当缓存快满时, 需要将一些数据干掉以释放空间, 通常使用LRU算法, 也可以根据自己业务来自定义算法. 注意淘汰数据的时候最好综合考虑从数据库读取数据的成本和保留缓存数据的成本以及处理淘汰策略的成本.
* 预热(Priming): 在应用启动时将可能会访问到的数据提前加载到缓存, 以避免启动时服务和数据库的过载.
* 一致性风险: 虽然应用内的代码会尽量处理好一致性问题, 但难免出现遗漏, 以及从其他程序对数据库的修改. 尤其是当复制库之间进行频繁同步的时候, 可能会导致难以理解的一致性问题.
* 本地缓存: 使用本机内存作为缓存会在集群环境下带来一些不便. 不同节点间的缓存数据会快速出现大量不一致. 对数据快速过期只能缓解症状. 

#### 使用场景:

数据分布在一个较大的范围内(无法完全载入缓存), 并且实际数据需求难以预测, 因此将数据向缓存的加载推迟到数据将要被使用时.      
另外要注意, 对于web应用的会话信息不适用该模式.


## Circuit Breaker 模式

该模式用于在访问远端数据或服务时出现的临时性的失败或异常时进行控制.

简单使用 retry 反而会使得系统资源被迅速耗尽, 直至崩溃. 此时旧需要这种断路器模式了. 

该模式的本质是个状态机, 来模拟电路中的断路器. 它具有三种状态: 

* Closed: 闭合状态. 此时正常请求, 如果出现错误则记录次数, 当一段时间内的错误率达到一定阈值, 则变为 Open 状态, 同时启动一个 timeout 定时器, 当定时器结束后状态将自动变为 Half-Open 状态.

* Open: 此时会立刻返回收到的请求, 而不再执行请求对应的操作.

* Half-Open: 这种状态下会尝试以限定的速度(次数)来执行操作并响应请求, 如果这些操作都成功, 则变为 Closed 状态并重置 failure 计数器, 此时服务恢复; 如果其中任何一个失败, 则再次将状态变为 Open 并设置新的 timeout 计时器.

通过合理设置 Half-Open 状态, 可以避免故障恢复后出现瞬间负载过高导致再次超时或故障.  当 Half-Open 状态再次转为 Open 状态时, 也可以逐步增加 timeout 计时器的时间.  实践中 Open 状态可以返回异常, 也可以返回一个有意义的默认值.


#### 注意:

* 对于比较复杂的情况, 可以根据失败时的不同异常类型来进行不同程度的处理.
* 注意控制计时器的时间, 太长会导致故障恢复后无法尽快转换状态, 太短会导致频繁在 Open 和 Half-Open 状态之间切换.
* 可以在 Open 状态下使用心跳检测或 ping 的方式来帮助尽早探测到服务的恢复, 以减少等待时间.
* 对于可能会故障很久的情况, 采用管理员手动切换状态的方式也是一个办法.
* 很多情况下, 断路器都需要应付高并发的场景, 请确保断路器实现能正确处理并发请求, 另外, 注意不要引入过高的性能开销. 
* 注意远端不同数据源的区别对待, 以免混淆. 比如数据库的不同 replication.
* 某些情况下可以记录 Open 状态时的请求, 当状态正常后再重放这些请求.



## Compensating Transaction 模式

为了消除事务而生.

应用所依赖并需要修改的数据通常并不在一个位置, 他们分布在不同的数据库, 机器, 机房, 城市. 实践中, 在这样的情况下去保证事务一致性是低效且不可取的. 事实上应该去保证最终一致性而不是事务一致性.

一系列相关操作的回滚不是简单的将数据恢复到操作之前, 而是需要考虑到在这期间的其他并发操作的影响, 考虑到各个步骤间可能完全异构的数据持久化方式, 考虑服务本身状态变化的回滚等许多复杂因素.


